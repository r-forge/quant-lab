{
    "contents" : "# Quant-lab functions\n\n##### libraries #####\n\nlist.of.packages <- c(\"fOptions\", \"RPostgreSQL\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\nsapply(list.of.packages, require, character.only=TRUE)\nrm(list.of.packages, new.packages)\n\n\n\n##### options #####\n\n#options(stringsAsFactors = FALSE)\n\n\n\n##### GreeksBSM #####\n\n# Function calculates option premium and sensitivities,\n# setting b = r we get Black and Scholes' stock option model,\n# b = r-q we get Merton's stock option model with continuous dividend yield q,\n# b = 0 we get Black's futures option model,\n# and b = r-rf we get Garman and Kohlhagen's currency option model with \n# foreign interest rate rf\n\nGreeksBSM <- function(\n  name  = c(\"premium\", \"delta\", \"vega\", \"theta\", \"rho\", \"gamma\", \"vanna\", \"volga\"),\n  type = c(\"c\", \"p\"),\n  S = 0,\n  K = 0,\n  T = 0,\n  r = 0,\n  b = 0,\n  vola = 0\n)\n{\n\n  c.type <- c(\"premium\", \"delta\", \"vega\", \"theta\", \"rho\", \"gamma\", \"vanna\", \"volga\")\n  \n  {# check input params\n  \n  if(type == \"c\" | type == \"C\" | type == \"call\" | type == \"Call\") {\n    i <- 1\n  } else {\n    if(type == \"p\" | type == \"P\" | type == \"put\" | type == \"Put\") {\n      i <- -1\n    } else {\n      err <- \"Type out of c(c, p, call, put, Call, Put)\"\n      return(list(err=err, value=NA))\n    }\n  }\n  \n  if(!(name %in% c.type)) {\n    err <- \"Name out of c(premium, delta, vega, theta, rho, gamma, vanna, volga)\"\n    return(list(err=err, value=NA))\n  }\n  \n  if(S <= 0) {\n    err <- \"S must have a positive value\"\n    return(list(err=err, value=NA))\n  }\n  \n  if(K <= 0) {\n    err <- \"K must have a positive value\"\n    return(list(err=err, value=NA))\n  }\n  \n  if(T <= 0) {\n    out <- 0\n    if(name == \"premium\") out <- i * (S - K)\n    if(name == \"delta\") out <- i\n    return(list(err=0, value=out))\n    #err <- \"T must have a positive value\"\n    #return(list(err=err, value=NA))\n  }\n  \n  if(vola <= 0) {\n    err <- \"vola must have a positive value\"\n    return(list(err=err, value=NA))\n  }\n  \n  }\n  \n  q <- r - b\n  d1 <- (log(S/K) + (r - q + vola*vola/2) * T)/(vola * sqrt(T))\n  d2 <- d1 - vola * sqrt(T)\n  \n  if(name == \"premium\") {\n    out <- i * (S * exp(-q*T) * pnorm(i*d1) - K * exp(-r*T) * pnorm(i*d2))\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"delta\") {\n    out <- i*exp(-q*T) * pnorm(i*d1)\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"vega\") {\n    out <- S * exp(-q*T) * dnorm(d1) * sqrt(T)\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"theta\") {\n    out <- -exp(-q*T) * S*dnorm(d1)*vola/(2*sqrt(T)) - i*r*K*exp(-r*T)*pnorm(i*d2) +\n      i*q*S*exp(-q*T)*pnorm(i*d1)\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"rho\") {\n    out <- i*K * T * exp(-r*T) * pnorm(i*d2)\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"gamma\") {\n    out <- exp(-q*T) * dnorm(d1)/(S*vola*sqrt(T))\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"vanna\") {\n    out <- -exp(-q*T) * dnorm(d1) * d2/vola\n    return(list(err=0, value=out))\n  }\n  \n  if(name == \"volga\") {\n    out <- S * exp(-q*T) * dnorm(d1) * sqrt(T) * (d1*d2)/vola\n    return(list(err=0, value=out))\n  }\n\n}\n\n\n\n##### StrikeDeltaConv #####\n\n# Calculates the strike price of an option with given values of the delta,\n# underlying price, implied volatility,...\n\nStrikeDeltaConv <- function(\n  delta = 0,\n  S = 0,\n  T = 0,\n  r = 0,\n  b = 0,\n  vola = 0\n)\n{\n\n  q <- r - b\n  \n  if(delta > 0) {\n    d1 <- qnorm(delta * exp(q * T))\n  } else {\n    d1 <- -qnorm(-delta * exp(q * T))\n  }\n  \n  return(S * exp(-d1 * vola * sqrt(T) + (r - q + vola*vola/2) * T))\n\n}\n\n\n\n##### VannaVolgaVol #####\n\n# The vanna-volga method to calculate implied volatility of an option\n\nVannaVolgaVol <- function(\n  method = c(\"continuous\", \"discrete\"),\n  S = 0,\n  K = 0,\n  T = 0,\n  vol0 = 0,\n  vola = data.frame(\n    K = c(0, 0, 0),\n    v = c(0, 0, 0)),\n  r = 0,\n  b = 0,\n  tol = 1e-5\n)\n{\n  \n  if(method == \"continuous\") {\n  \n    C <- c(function(vol=vol0, spot=S) GreeksBSM(name=\"premium\", type=\"c\", S=spot, K=vola$K[1], T=T, \n      r=r, b=b, vola=vol)$value, function(vol=vol0, spot=S) GreeksBSM(name=\"premium\", type=\"c\", S=spot, \n      K=vola$K[2], T=T, r=r, b=b, vola=vol)$value, function(vol=vol0, spot=S) GreeksBSM(name=\"premium\",\n      type=\"c\", S=spot, K=vola$K[3], T=T, r=r, b=b, vola=vol)$value)\n    \n    TV.BS <- GreeksBSM(name=\"premium\", type=\"c\", S=S, K=K, T=T, r=r, b=b, vola=vol0)$value\n    \n    B.vega <- sapply(1:3, function(i) GreeksBSM(name=\"vega\", type=\"c\", S=S, K=vola$K[i], T=T,\n      r=r, b=b, vola=vol0)$value)\n    B.vanna <- sapply(1:3, function(i) GreeksBSM(name=\"vanna\", type=\"c\", S=S, K=vola$K[i], T=T,\n      r=r, b=b, vola=vol0)$value)\n    B.volga <- sapply(1:3, function(i) GreeksBSM(name=\"volga\", type=\"c\", S=S, K=vola$K[i], T=T,\n      r=r, b=b, vola=vol0)$value)\n    \n    O.vega <- GreeksBSM(name=\"vega\", type=\"c\", S=S, K=K, T=T, r=r, b=b, vola=vol0)$value\n    O.vanna <- GreeksBSM(name=\"vanna\", type=\"c\", S=S, K=K, T=T, r=r, b=b, vola=vol0)$value\n    O.volga <- GreeksBSM(name=\"volga\", type=\"c\", S=S, K=K, T=T, r=r, b=b, vola=vol0)$value\n\n    B.cost <- sapply(1:3, function(i) C[[i]](vol=vola$v[i]) - C[[i]](vol=vol0))\n    \n    A <- t(matrix(c(B.vega, B.vanna, B.volga), nrow = 3))\n    x <- matrix(c(O.vega, O.vanna, O.volga), nrow = 3)\n    w <- solve(A, x)\n    CF <- t(w) %*% matrix(B.cost, nrow = 3)\n    \n    vola <- GBSVolatility(price=TV.BS+CF, TypeFlag=\"c\", S=S, X=K, Time=T, r=r, b=b, tol=tol)\n    \n    return(vola)\n  \n  }\n  \n  if(method == \"discrete\") {\n  \n    dS <- S * 0.001\n    dvol <- vol0 * 0.01\n    \n    C <- c(function(vol=vol0, spot=S) GBSOption(TypeFlag=\"c\", S=spot, X=vola$K[1], Time=T, r=r, \n      b=b, sigma=vol)@price, function(vol=vol0, spot=S) GBSOption(TypeFlag=\"c\", S=spot, X=vola$K[2],\n      Time=T, r=r, b=b, sigma=vol)@price, function(vol=vol0, spot=S) GBSOption(TypeFlag=\"c\", S=spot,\n      X=vola$K[3], Time=T, r=r, b=b, sigma=vol)@price)\n    \n    Vega <- function(f, vol, spot=S) (f(vol+dvol, spot) - f(vol-dvol, spot))/(2*dvol)\n    Vanna <- function(f, vol, spot=S) (Vega(f, vol, spot+dS) - Vega(f, vol, spot-dS))/(2*dS)\n    Volga <- function(f, vol) (Vega(f, vol+dvol) - Vega(f, vol-dvol))/(2*dvol)\n\n    O <- function(vol=vol0, spot=S) GBSOption(TypeFlag=\"c\",  S=spot, X=K, Time=T, r=r, b=b, \n      sigma=vol)@price\n    \n    TV.BS <- O()\n    \n    B.vega <- sapply(1:3, function(i) Vega(C[[i]], vol0))\n    B.vanna <- sapply(1:3, function(i) Vanna(C[[i]], vol0))\n    B.volga <- sapply(1:3, function(i) Volga(C[[i]], vol0))\n    \n    O.vega <- Vega(O, vol0)\n    O.vanna <- Vanna(O, vol0)\n    O.volga <- Volga(O, vol0)\n    \n    B.cost <- sapply(1:3, function(i) C[[i]](vola$v[i]) - C[[i]](vol0))\n    \n    A <- t(matrix(c(B.vega, B.vanna, B.volga), nrow = 3))\n    x <- matrix(c(O.vega, O.vanna, O.volga), nrow = 3)\n    w <- solve(A, x)\n    CF <- t(w) %*% matrix(B.cost, nrow = 3)\n    \n    vola <- GBSVolatility(price=TV.BS+CF, TypeFlag=\"c\", S=S, X=K, Time=T, r=r, b=b, tol=tol)\n    \n    return(vola)\n  \n  }\n  \n  return(NA)\n  \n}\n\n\n\n##### CutSplineFun #####\n\n# Spline function\n\nCutSplineFun <- function(\n  xy = data.frame(x = NULL, y = NULL),\n  x = NULL\n)\n{\n  \n  if(nrow(xy) == 0)\n    return(0)\n  \n  if(x < min(xy[, 1]))\n    return(xy[xy[, 1] == min(xy[, 1]), 2])\n  \n  if(x > max(xy[, 1]))\n    return(xy[xy[, 1] == max(xy[, 1]), 2])\n  \n  return(splinefun(xy[, 1], xy[, 2])(x))\n  \n}\n\n\n\n##### PortfolioValue #####\n\n# The Profit & Loss and Greeks calculation of an option portfolio using\n# the vanna-volga method and given volatility scenario\n\nPortfolioValue <- function(\n  param = c(\"premium\", \"delta\", \"vega\", \"theta\", \"gamma\"),\n  S = 0,\n  T = 0,\n  r = 0,\n  b = 0,\n  tol = 1e-5,\n  vola.vv = c(ATM = NULL, RR25 = NULL, BF25 = NULL),\n  vola.scen = list(ATM=data.frame(x = NULL, d = NULL),\n  RR25 = data.frame(x = NULL, d = NULL),\n  BF25 = data.frame(x = NULL, d = NULL)),\n  dS = S/1000,\n  port = data.frame(type = NULL, strike = NULL, vola = NULL, quant = NULL)\n)\n{\n\n  {# check input params\n  \n  if(is.null(port$vola) & is.null(vola.vv)) {\n    err <- \"Please define port$vola or vola.vv\"\n    return(list(err=err, value=NA))\n  }\n  \n  if(nrow(port) < 1) {\n    err <- \"Portfolio is empty\"\n    return(list(err=err, value=0))\n  }\n  \n  if(!is.null(vola.scen$ATM) && nrow(vola.scen$ATM) == 0) vola.scen$ATM <- NULL\n  if(!is.null(vola.scen$RR25) && nrow(vola.scen$RR25) == 0) vola.scen$RR25 <- NULL\n  if(!is.null(vola.scen$BF25) && nrow(vola.scen$BF25) == 0) vola.scen$BF25 <- NULL\n  if(is.null(vola.scen$ATM) & is.null(vola.scen$RR25) & is.null(vola.scen$BF25)) vola.scen <- NULL\n  \n  }\n  \n  if(param == \"premium\") {\n    \n    value <- 0\n    \n    for(i in 1:nrow(port)) {\n    \n      if(port$type[i] == \"u\") {\n      \n        value <- value + port$quant[i] * S\n        \n      } else {\n      \n        if(is.null(vola.vv)) {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          vola <- port$vola[i] + ATM.d\n          \n        } else {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n        \n        }\n        \n        p <- GreeksBSM(name=\"premium\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n        \n        if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n        \n        value <- value + p * port$quant[i]\n        \n      }\n    \n    }\n    \n    return(list(err=0, value=value))\n    \n  }\n\n  if(param == \"delta\") {\n  \n    value <- 0\n    \n    for(i in 1:nrow(port)) {\n    \n      if(port$type[i] == \"u\") {\n      \n        value <- value + port$quant[i]\n        \n      } else {\n      \n        if(is.null(vola.vv)) {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          vola <- port$vola[i] + ATM.d\n          \n          p <- GreeksBSM(name=\"delta\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        } else {\n        \n          {# V(S-dS)\n          \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S-dS)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S-dS)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S-dS)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S-dS\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S-dS, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S-dS, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S-dS, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n\n          p1 <- GreeksBSM(name=\"premium\", type=port$type[i], S=S-dS, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p1$err == 0) p1 <- p1$value else return(list(err=p1$err, value=NA))\n          \n          }\n          \n          {# V(S+dS)\n          \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S+dS)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S+dS)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S+dS)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S+dS\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S+dS, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S+dS, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S+dS, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n\n          p2 <- GreeksBSM(name=\"premium\", type=port$type[i], S=S+dS, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p2$err == 0) p2 <- p2$value else return(list(err=p2$err, value=NA))\n          \n          }\n          \n          p <- (p2 - p1)/(2 * dS)\n          \n        }\n        \n        value <- value + p * port$quant[i]\n      \n      }\n    \n    }\n    \n    return(list(err=0, value=value))\n  \n  }\n\n  if(param == \"vega\") {\n  \n    value <- 0\n    \n    for(i in 1:nrow(port)) {\n    \n      if(port$type[i] != \"u\") {\n      \n        if(is.null(vola.vv)) {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          vola <- port$vola[i] + ATM.d\n          \n          p <- GreeksBSM(name=\"vega\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        } else {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n\n          p <- GreeksBSM(name=\"vega\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        }\n        \n        value <- value + p * port$quant[i]\n      \n      }\n    \n    }\n    \n    return(list(err=0, value=value))\n  \n  }\n\n  if(param == \"theta\") {\n  \n    value <- 0\n    \n    for(i in 1:nrow(port)) {\n    \n      if(port$type[i] != \"u\") {\n      \n        if(is.null(vola.vv)) {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          vola <- port$vola[i] + ATM.d\n        \n          p <- GreeksBSM(name=\"theta\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        } else {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n\n          p <- GreeksBSM(name=\"theta\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        }\n        \n        value <- value + p * port$quant[i]\n      \n      }\n    \n    }\n    \n    return(list(err=0, value=value))\n  \n  }\n\n  if(param == \"gamma\") {\n  \n    value <- 0\n    \n    for(i in 1:nrow(port)) {\n    \n      if(port$type[i] != \"u\") {\n      \n        if(is.null(vola.vv)) {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          vola <- port$vola[i] + ATM.d\n        \n          p <- GreeksBSM(name=\"gamma\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        } else {\n        \n          if(is.null(vola.scen$ATM)) ATM.d <- 0 else ATM.d <- CutSplineFun(vola.scen$ATM, S)\n          if(is.null(vola.scen$RR25)) RR25.d <- 0 else RR25.d <- CutSplineFun(vola.scen$RR25, S)\n          if(is.null(vola.scen$BF25)) BF25.d <- 0 else BF25.d <- CutSplineFun(vola.scen$BF25, S)\n          \n          ATM.vol <- vola.vv[[\"ATM\"]] + ATM.d\n          C25.vol <- (vola.vv[[\"RR25\"]] + RR25.d)/2 + (vola.vv[[\"BF25\"]] + BF25.d) + ATM.vol\n          P25.vol <- C25.vol - (vola.vv[[\"RR25\"]] + RR25.d)\n          ATM.K <- S\n          C25.K <- StrikeDeltaConv(delta=0.25, S=S, T=T, r=r, b=b, vola=C25.vol)\n          P25.K <- StrikeDeltaConv(delta=-0.25, S=S, T=T, r=r, b=b, vola=P25.vol)\n          \n          vola <- VannaVolgaVol(method=\"continuous\", S=S, K=port$strike[i], T=T, vol0=ATM.vol,\n            vola=data.frame(K=c(P25.K, ATM.K, C25.K), v=c(P25.vol, ATM.vol, C25.vol)),\n            r=r, b=b, tol=tol)\n\n          p <- GreeksBSM(name=\"gamma\", type=port$type[i], S=S, K=port$strike[i], T=T, r=r, b=b, vola=vola)\n          \n          if(p$err == 0) p <- p$value else return(list(err=p$err, value=NA))\n          \n        }\n        \n        value <- value + p * port$quant[i]\n      \n      }\n    \n    }\n    \n    return(list(err=0, value=value))\n  \n  }\n\n}\n\n\n\n##### configPG #####\n\nconfigPG <- list(\n  user = \"postgres\",\n  password = \"postgres\",\n  dbname = \"postgres\",\n  host = \"127.0.0.1\",\n  port = 5432,\n  drv = \"PostgreSQL\"\n)\n\n# configPGAdmin <- list(\n#   user = \"username_of_admin\",\n#   password = \"password_of_admin\",\n#   dbname = \"MY_DBNAME\",\n#   host = \"url_of_host\",\n#   port = port_of_host,\n#   drv = \"PostgreSQL\"\n# )\n\n# configMySQL <- list(\n#   user = \"username\",\n#   password = \"password\",\n#   dbname = \"MY_DBNAME\",\n#   host = \"MY_HOST_IP_ADDRESS\",\n#   drv = \"MySQL\"\n# )\n\n# configWhse <- list(\n#   drv = JDBC(\"oracle.jdbc.OracleDriver\", \"/usr/lib/oracle/instantclient_11_2/ojdbc5.jar\"),\n#   user = \"username\",\n#   password = \"password\",\n#   url =  \"url\"\n# )\n\n\n\n##### makeCxn #####\n\n# Make a connection to a database\n# This function abstracts the idea of a database connection, allowing variable\n# parameters depending on the type of database you're connecting to\n# @param config a named list of the configuration options for the database connection\n# @return a connection to the database defined in the config\n\nmakeCxn <- function(config)\n{\n  \n  if(class(config[['drv']]) == \"character\")\n    config[['drv']] <- dbDriver(config[['drv']])\n  \n  do.call(dbConnect, config)\n  \n}\n\n\n\n##### fetchQuery #####\n\n# This function runs a query on a database, fetching the result if desired\n# The purpose of this function is to remove connection management from the querying process\n# @param query the query you want to make to the SQL connection you've specified\n# @param config a named list of the configuration options for the connection\n# @param n the number of rows to return, or -1 for all rows\n# @param verbose Should the queries be printed as they're made?\n# @param split Should the queries be split on semicolons, or run as a block?\n# @return A list of results if multiple queries, or a single result if one query.\n\nfetchQuery <- function(\n  query,\n  config = configPG,\n  split = FALSE,\n  verbose = TRUE,\n  n = -1\n)\n{\n  \n  res <- list()\n  cxn <- makeCxn(config)\n  t1 <- Sys.time()\n  queries <- query\n  \n  if(split == TRUE)\n    queries <- strsplit(query, \";\", fixed = TRUE)[[1]] # Split the query into components\n  \n  for(item in queries) {\n    \n    if(verbose) {\n      cat(paste(item, '\\n'))\n    }\n    \n    tmp <- try(dbSendQuery(cxn, item)) # send the query\n    \n    if ('try-error' %in% class(tmp)) {\n      res[[item]] <- dbGetException(cxn)\n      next\n    }\n    \n    type <- tolower(substring(gsub(\" \", \"\", item), 0, 6)) # identify if select, insert, delete\n    \n    if (type == \"select\" | grepl(\"with..\", type) | grepl('EXPLAI|explai', type) | !split) {\n      res[[item]] <- try(fetch(tmp, n))\n    } else {\n      res[[item]] <- dbGetRowsAffected(tmp)\n      cat(res[[item]])\n    }\n    \n    if (verbose) {\n      print(Sys.time() - t1)\n      if (!is.null(dim(res))) {\n        print(dim(res))\n      }\n    }\n    \n    dbClearResult(tmp)\n    \n  }\n  \n  dbDisconnect(cxn)\n  \n  if (length(res) == 1) {\n    res <- res[[1]]\n  }\n  \n  return(res)\n  \n}\n\n\n\n\n\n\n\n\n\n",
    "created" : 1403862793406.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2900882449",
    "id" : "6894EB2E",
    "lastKnownWriteTime" : 1403862770,
    "path" : "C:/Projects/R/my packages/QUANTlab/R/quant-lab.r",
    "project_path" : "R/quant-lab.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}